import hashlib
import json
import pandas as pd
import matplotlib.pyplot as plt
from time import time
from typing import Dict, List

class Block:
    def __init__(self, index: int, previous_hash: str, timestamp: float, transactions: List[Dict], proof: int):
        self.index = index
        self.previous_hash = previous_hash
        self.timestamp = timestamp
        self.transactions = transactions
        self.proof = proof

    def to_dict(self) -> Dict:
        return {
            "index": self.index,
            "previous_hash": self.previous_hash,
            "timestamp": self.timestamp,
            "transactions": self.transactions,
            "proof": self.proof
        }

    def __str__(self) -> str:
        return json.dumps(self.to_dict(), indent=4)

class Blockchain:
    def __init__(self):
        self.chain = []
        self.current_transactions = []
        self.create_block(proof=100, previous_hash='1')  # Genesis block

    def create_block(self, proof: int, previous_hash: str = None) -> Block:
        block = Block(
            index=len(self.chain) + 1,
            previous_hash=previous_hash or self.hash(self.chain[-1]),
            timestamp=time(),
            transactions=self.current_transactions,
            proof=proof
        )
        self.current_transactions = []
        self.chain.append(block)
        return block

    def add_transaction(self, sender: str, recipient: str, amount: float) -> int:
        self.current_transactions.append({
            'sender': sender,
            'recipient': recipient,
            'amount': amount
        })
        return self.last_block.index + 1

    def proof_of_work(self, last_proof: int) -> int:
        proof = 0
        while not self.valid_proof(last_proof, proof):
            proof += 1
        return proof

    def valid_proof(self, last_proof: int, proof: int) -> bool:
        guess = f'{last_proof}{proof}'.encode()
        guess_hash = hashlib.sha256(guess).hexdigest()
        return guess_hash[:4] == "0000"

    def hash(self, block: Block) -> str:
        block_string = json.dumps(block.to_dict(), sort_keys=True).encode()
        return hashlib.sha256(block_string).hexdigest()

    def get_block(self, index: int) -> Block:
        if index < 1 or index > len(self.chain):
            return None
        return self.chain[index - 1]

    @property
    def last_block(self) -> Block:
        return self.chain[-1]

class ChainPulseAnalytics:
    def __init__(self):
        self.blockchain = Blockchain()

    def add_transaction(self, sender: str, recipient: str, amount: float) -> str:
        index = self.blockchain.add_transaction(sender, recipient, amount)
        return f"Transaction will be added to Block {index}"

    def mine_block(self) -> str:
        last_proof = self.blockchain.last_block.proof
        proof = self.blockchain.proof_of_work(last_proof)
        self.blockchain.create_block(proof)
        return f"Block mined with proof {proof}"

    def get_block_data(self, index: int) -> Dict:
        block = self.blockchain.get_block(index)
        if block:
            return block.to_dict()
        else:
            return "Block not found"

    def analyze_blocks(self) -> pd.DataFrame:
        block_data = []
        for block in self.blockchain.chain:
            block_data.append({
                "Index": block.index,
                "Timestamp": block.timestamp,
                "Proof": block.proof,
                "Transaction Count": len(block.transactions)
            })
        df = pd.DataFrame(block_data)
        return df

    def analyze_transactions(self) -> pd.DataFrame:
        transactions = []
        for block in self.blockchain.chain:
            for tx in block.transactions:
                transactions.append(tx)
        df = pd.DataFrame(transactions)
        return df

    def plot_block_data(self):
        df = self.analyze_blocks()
        df.set_index('Index', inplace=True)
        df[['Transaction Count', 'Proof']].plot(kind='bar', figsize=(12, 6))
        plt.title('Block Data Analysis')
        plt.xlabel('Block Index')
        plt.ylabel('Value')
        plt.show()

    def plot_transaction_distribution(self):
        df = self.analyze_transactions()
        df['sender'].value_counts().plot(kind='bar', figsize=(12, 6), color='b', alpha=0.7, label='Senders')
        df['recipient'].value_counts().plot(kind='bar', figsize=(12, 6), color='r', alpha=0.7, label='Recipients')
        plt.title('Transaction Distribution')
        plt.xlabel('Address')
        plt.ylabel('Count')
        plt.legend()
        plt.show()

# Example Usage
if __name__ == "__main__":
    analytics = ChainPulseAnalytics()

    # Add transactions
    print(analytics.add_transaction("Alice", "Bob", 50))
    print(analytics.add_transaction("Bob", "Charlie", 30))

    # Mine a block
    print(analytics.mine_block())

    # Get block data
    print("\nBlock Data for Block 1:")
    print(analytics.get_block_data(1))

    # Analyze and plot block and transaction data
    print("\nBlock Data Analysis:")
    print(analytics.analyze_blocks())

    print("\nTransaction Data Analysis:")
    print(analytics.analyze_transactions())

    print("\nPlotting Block Data:")
    analytics.plot_block_data()

    print("\nPlotting Transaction Distribution:")
    analytics.plot_transaction_distribution()
